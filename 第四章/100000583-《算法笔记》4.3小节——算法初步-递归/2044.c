/*2044
思考
	- 共有n个物品，物品的总体积必须是40，才可得到这些物品，
	- n(1 <= n <= 20),表示不同的物品的数目,
	- 输出不同的选择物品的方式的数目。
	- 递归的边界就是 当sum==0,也就是我们前面取到的物品已经凑到了sum,
	- 所以不需要再继续取物品去凑体积的时候,表示我们已经凑成了一种情况,返回1 
	- 当 n<=0时,也就是前面已经没有东西可取了的时候,表示我们凑不成目标体积sum了,返回0
	- 从最后一个往前取可以分为两个情况
		- 不取最后一个,取前面的就可以凑成40
		- 取最后一个,那么我们接着取前面的话就要将体积凑成40减去我们已经取得的物品的体积
		- 两者相加就是取法的总数
	- 将递归函数定义成 int F(int n,int sum), a表示前面还有n个物品,sum表示我们需要凑成的体积总数
	- 那么这两种情况就可以表示成(假设用str数组存储每个物品的体积)
	- 1.F(n-1,sum)	2.F(n-1,sum-str(n-1))
*/
#include <stdio.h>
int str[25];
int F(int n,int sum){ //n表示前面还有n个物品,sum表示我们需要凑成的体积总数
	if(sum==0)	return 1; //取到的物品已经凑到了sum
	if(n<=0)	return 0; //前面已经没有东西可取了
	return F(n-1,sum)+F(n-1,sum-str[n]); //从最后一个往前取可以分为两个情况
}
int main(){
	int n,i;
	while(scanf("%d",&n)!=EOF){
		for(i=1;i<=n;i++){
			scanf("%d",&str[i]);
		}
		printf("%d\n",F(n,40));
	}	
	return 0;
}
